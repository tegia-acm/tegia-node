
#include "pool.h"


namespace tegia {
namespace threads {


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////


pool::pool()
{
	this->queue = new tegia::threads::queue();
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////


pool::~pool()
{
	delete this->queue;
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////


int pool::init(int threads_count, std::function<::tegia::context2 const * ()> _thread_init, std::function<void()> _callback)
{
	this->threads_count = threads_count;
	this->_callback = _callback;

	for(int i = 0; i < threads_count; i++)
	{
		auto pWorker = std::make_shared<tegia::threads::worker>(
			this->queue,
			std::bind(&pool::thread_init,this, std::placeholders::_1, _thread_init)
		);

		std::cout << _RED_TEXT_ << "tid = " << pWorker->tid << _BASE_TEXT_ << std::endl;

		this->_workers.emplace(pWorker->tid, pWorker);
	}

	return 0;	
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////


::tegia::context2 const * pool::thread_init(const std::string &tid, std::function<::tegia::context2 const * ()> _thread_init)
{
	::tegia::context2 const * context = _thread_init();
	this->signal(tid);
	return context;
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void pool::signal(const std::string &tid)
{
	this->signal_mutex.lock();
	this->_workers_status.insert({tid,true});
	if(this->_workers_status.size() == this->threads_count)
	{
		this->_callback();
	}
	this->signal_mutex.unlock();
	// return 0;
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////


int pool::add_task(std::function<void(::tegia::context2 const *)> _fn, int priority)
{
	auto _task = new tegia::threads::task(tegia::random::uuid());
	_task->fn = _fn;
	this->queue->add(_task, priority);
	return 0;
};



}  // namespace threads
}  // namespace tegia


